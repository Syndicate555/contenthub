Let’s walk through the full “Connect Twitter → pull all bookmarks into ContentHub” flow like you’re about to actually build it.

I’ll keep it tech stack agnostic, but assume something like Next.js frontend + Node/Express or Next API routes on the backend.

1. High level flow

From the user’s point of view

They click “Connect X (Twitter)” in ContentHub

They’re redirected to X’s consent screen

They approve access

They land back in ContentHub with a “Connected” state

ContentHub starts syncing their bookmarks in the background

They see bookmarked tweets appear in their ContentHub feed

Under the hood, this is:

OAuth 2.0 Authorization Code with PKCE to get a user access token

Store that token and the X user id for your ContentHub user

Call GET /2/users/{id}/bookmarks with the right scopes and pagination until done
X Developer Platform
+1

2. Step zero: set up your X developer app

You do this once for the whole product.

Go to developer.x.com and create a developer account and project
Bika
+1

Inside the project, create an App.

In the App settings, configure:

App permissions: you need read access to tweets and bookmarks

OAuth 2.0 settings:

Callback URL, for example
https://contenthub.app/api/auth/x/callback

Website URL, e.g. https://contenthub.app

In “User authentication settings”, enable OAuth 2.0 with Authorization Code + PKCE.

Note your:

Client ID

Client secret

App ID (mainly for reference)

You also need the right paid access plan. X’s docs say some endpoints (including bookmarks create/delete) require enrollment in a relevant API access plan. Bookmarks lookup uses the X API and has its own limits per plan.
X Developer Platform
+1

3. The data model on your side

Minimal schema:

users

id

email

etc

x_connections

id

user_id (FK to your users table)

x_user_id (string, from X, like "2244994945")

access_token (encrypted at rest)

refresh_token (if provided, encrypted)

scopes (comma separated or JSON)

expires_at (timestamp, optional)

connected_at

content_items

id

user_id

source (e.g. "x")

source_id (tweet id)

raw (JSON blob of full tweet payload)

text

author_name

author_username

url

created_at (tweet created time)

inserted_at (when you stored it)

You’ll also want an index on (user_id, source, source_id) to de-dupe easily.

4. Frontend: “Connect X” button and PKCE start

On your settings page:

User clicks “Connect X”.

Frontend generates PKCE values:

code_verifier: random high entropy string

code_challenge: BASE64URL( SHA256(code_verifier) )

Store code_verifier client side for a few minutes:

In localStorage

Or in a short-lived encrypted cookie

Build the authorization URL:

https://twitter.com/i/oauth2/authorize with query params:

response_type=code

client_id=YOUR_CLIENT_ID

redirect_uri=https://contenthub.app/api/auth/x/callback

scope=tweet.read users.read bookmark.read offline.access

state=<random_csrf_token>

code_challenge=<code_challenge>

code_challenge_method=S256

The docs for bookmarks say you need tweet.read, users.read, and bookmark.read scopes. offline.access gives you refresh tokens.
X Developer
+1

Store the state value (e.g. in a secure cookie) so you can check CSRF later.

Redirect the user to that URL.

5. Backend: OAuth callback and token exchange

Your redirect URI points to something like
POST /api/auth/x/callback (or GET, depending how you wire it).

When X redirects back, you get:

code

state

Maybe error if the user denied access

Your callback handler does:

Verify state matches what you set earlier. If mismatch, reject.

Read the code_verifier from where you stored it.

Exchange the code for tokens by calling X’s token endpoint from your backend:

POST https://api.x.com/2/oauth2/token with body such as:

grant_type=authorization_code

code=<code_from_query>

redirect_uri=<same_redirect_uri>

client_id=<your_client_id>

code_verifier=<code_verifier>

You’ll get back JSON like:

access_token

refresh_token (if offline access scope)

expires_in

scope

token_type (Bearer)

Now you need the user’s X id. Call:

GET https://api.x.com/2/users/me
with Authorization: Bearer <access_token> and scopes tweet.read users.read.
X Developer Platform
+1

The response includes data.id which is the X user id string.

Upsert into x_connections:

Look up the logged in ContentHub user user_id.

If an x_connections row exists for that user_id, update it.

Otherwise insert new.

Redirect the user to something like /settings/integrations?x=connected.

At this point, ContentHub is authorized to make X API calls on behalf of that user.

6. Service to fetch bookmarks

Now the fun part. The bookmarks endpoint:

GET https://api.x.com/2/users/{id}/bookmarks
X Developer Platform
+1

Key points:

Auth: OAuth 2.0 user context with the access token

Scopes: tweet.read users.read bookmark.read
X Developer

Rate limit: about 180 requests per 15 minutes per user for GET bookmarks
X Developer
+1

It returns up to the 800 most recent bookmarks, with pagination
X Developer
+1

You probably want a background job worker rather than doing this in the request/response path.

Initial full import

Pseudo algorithm for a worker job:

async function syncXBookmarksForUser(userId: string) {
  const conn = await db.x_connections.findOne({ user_id: userId })
  if (!conn) return

  let paginationToken: string | undefined = undefined
  let keepGoing = true

  while (keepGoing) {
    const params = new URLSearchParams({
      max_results: '100', // max per page
      'tweet.fields': 'created_at,public_metrics,entities',
      'user.fields': 'name,username,profile_image_url',
      expansions: 'author_id'
    })
    if (paginationToken) {
      params.set('pagination_token', paginationToken)
    }

    const res = await fetch(
      `https://api.x.com/2/users/${conn.x_user_id}/bookmarks?${params}`,
      {
        headers: {
          Authorization: `Bearer ${conn.access_token}`
        }
      }
    )

    if (res.status === 401) {
      // handle expired/invalid token, maybe try refresh flow then stop
      break
    }
    if (res.status === 429) {
      // rate limited, reschedule job later
      break
    }

    const body = await res.json()

    const tweets = body.data ?? []
    const includes = body.includes ?? {}
    const usersById = new Map(
      (includes.users ?? []).map((u: any) => [u.id, u])
    )

    // Upsert all tweets into content_items
    for (const t of tweets) {
      const author = usersById.get(t.author_id)
      await db.content_items.upsert({
        user_id: userId,
        source: 'x',
        source_id: t.id,
        text: t.text,
        raw: t,
        author_name: author?.name ?? null,
        author_username: author?.username ?? null,
        url: `https://x.com/${author?.username ?? 'i'}/status/${t.id}`,
        created_at: t.created_at
      })
    }

    const meta = body.meta ?? {}
    if (meta.next_token) {
      paginationToken = meta.next_token
    } else {
      keepGoing = false
    }

    if (!tweets.length) {
      keepGoing = false
    }
  }

  // mark sync finished in some table if you want
}


Important details:

Use max_results=100 (max allowed) to reduce requests.

Use expansions=author_id and user.fields to get author info in a single call.

Stop when there is no next_token or data is empty.

Because X only exposes up to ~800 of the most recent bookmarks, if a user has years of bookmarks they won’t all come through. That’s a platform limit, not your code.
Stack Overflow
+1

Incremental sync

After the initial import, you don’t want to constantly refetch everything.

One simple pattern:

Store the newest bookmark tweet id you have for that user in x_connections.last_bookmark_id.

On sync:

Call bookmarks without pagination first.

Iterate until you hit a tweet id you already know.

Stop there.

Because bookmarks endpoint returns newest first, this is efficient.

Rough outline:

async function syncNewBookmarksForUser(userId: string) {
  const conn = await db.x_connections.findOne({ user_id: userId })
  if (!conn) return

  const lastKnownId = conn.last_bookmark_id

  let paginationToken: string | undefined = undefined
  let firstNewId: string | undefined = undefined
  let seenExisting = false

  while (!seenExisting) {
    // same request shape as before
    // ...
    const body = await res.json()
    const tweets = body.data ?? []

    for (const t of tweets) {
      if (!firstNewId) firstNewId = t.id

      if (t.id === lastKnownId) {
        seenExisting = true
        break
      }

      // upsert tweet as before
    }

    if (seenExisting) break

    const meta = body.meta ?? {}
    if (!meta.next_token || !tweets.length) break
    paginationToken = meta.next_token
  }

  if (firstNewId) {
    await db.x_connections.update(
      { user_id: userId },
      { last_bookmark_id: firstNewId }
    )
  }
}


You can run this sync:

On demand when the user opens the “Twitter” tab in ContentHub.

Periodically with a cron (every 15 minutes or every few hours) as long as you respect rate limits.

7. Handling tokens, refreshing, and revocation

A few things to build in:

Token expiry

Store expires_at calculated from expires_in.

Before each call, if token is expired and you have a refresh_token, hit the token endpoint with grant_type=refresh_token and update your stored tokens.

Revoked or missing scopes

If X returns 401 or 403, catch it.

Mark the connection as status="needs_reauth" and prompt the user in the UI to reconnect.

Security

Encrypt tokens at rest.

Never expose them to the frontend directly. Every X API call should go via your backend.

8. UX inside ContentHub

Make it feel smooth:

On the integrations page:

Show “Connect X” when there is no x_connections row.

After callback completes, show “Connected” with:

“Last synced 5 min ago”

“Sync now” button that triggers a manual job.

On the main ContentHub feed:

Once bookmarks start coming in, show them like any other item with:

Tweet text

Author avatar and username

“Open on X” link

Platform badge “X”

You can even add filters like “Source: X” or “Type: Thread” later.

9. Edge cases and product decisions

A couple of things to keep in mind:

Old bookmarks: you will not be able to grab more than the most recent set X exposes, today that is documented as up to 800 posts per user, with pagination.
X Developer
+1

Deleted tweets: they might still show as bookmarks in X briefly, but the API may no longer return them or their content.

Private accounts: if the user has bookmarked tweets from protected accounts, your app can still see them via the API as long as the authenticated user has access.
