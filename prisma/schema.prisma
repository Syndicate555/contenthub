// ContentHub - Prisma Schema
// Personal "second brain" for social media content

generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id        String   @id @default(cuid())
  clerkId   String   @unique
  email     String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  items             Item[]
  socialConnections SocialConnection[]
  userDomains       UserDomain[]
  focusAreas        FocusArea[]
  xpEvents          XPEvent[]
  stats             UserStats?
  userBadges        UserBadge[]
  feedbacks         Feedback[]
  auditLogs         AuditLog[]
}

// ============================================
// GAMIFICATION MODELS
// ============================================

// Domain represents a knowledge/skill category (e.g., Finance, Career, Health)
model Domain {
  id          String  @id @default(cuid())
  name        String  @unique // "finance", "career", "health", etc.
  displayName String // "Finance", "Career", "Health", etc.
  description String? // Brief description of the domain
  icon        String? // Emoji or icon identifier
  color       String? // Hex color for UI theming
  order       Int     @default(0) // Display order

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  userDomains UserDomain[]
  focusAreas  FocusArea[]
  items       Item[] // Items in this domain
  xpEvents    XPEvent[] // XP events in this domain
  badges      Badge[] // Domain-specific badges

  @@index([name])
}

// UserDomain tracks a user's progress in a specific domain
model UserDomain {
  id       String @id @default(cuid())
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  domainId String
  domain   Domain @relation(fields: [domainId], references: [id], onDelete: Cascade)

  // Progress tracking
  totalXp   Int @default(0) // Total XP earned in this domain
  level     Int @default(1) // Current level (calculated from XP)
  itemCount Int @default(0) // Number of items processed in this domain

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, domainId]) // One record per user per domain
  @@index([userId])
  @@index([domainId])
}

// FocusArea tracks user's active focus areas (max 3)
model FocusArea {
  id       String @id @default(cuid())
  userId   String
  user     User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  domainId String
  domain   Domain @relation(fields: [domainId], references: [id], onDelete: Cascade)

  // Priority (1, 2, or 3 for primary, secondary, tertiary)
  priority Int @default(1)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, domainId]) // Can't have same domain twice
  @@unique([userId, priority]) // Each priority level is unique per user
  @@index([userId])
}

// Feedback & Support submissions
model Feedback {
  id            String   @id @default(cuid())
  userId        String
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  kind          String // feedback | support
  type          String // feature idea, ux, bug, access, etc.
  area          String?
  severity      String?
  rating        Int?
  title         String?
  body          String
  allowFollowUp Boolean  @default(false)
  contactEmail  String
  route         String?
  userAgent     String?
  status        String   @default("new")
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([userId])
  @@index([kind])
  @@index([status])
}

// RateLimit tracks API request counts for rate limiting and DDOS protection
model RateLimit {
  id String @id @default(cuid())

  // Identifier (userId for auth, IP for public, token for API keys)
  identifier String

  // Endpoint pattern (e.g., "POST:/api/items", "GET:/api/auth/twitter")
  endpoint String

  // Time window type ("minute", "hour", "day")
  window String

  // Window start timestamp (rounded down to window boundary)
  windowStart DateTime

  // Request count in this window
  count Int @default(1)

  // Metadata for logging
  lastRequestAt DateTime @default(now())
  lastIpAddress String?
  lastUserAgent String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Composite unique constraint: one record per identifier+endpoint+window+windowStart
  @@unique([identifier, endpoint, window, windowStart])
  // Indexes for cleanup and queries
  @@index([identifier, endpoint])
  @@index([windowStart]) // For cleanup of old records
  @@index([count]) // For finding abuse patterns
}

// AuditLog tracks security events and user actions for compliance and forensics
model AuditLog {
  id     String  @id @default(cuid())
  userId String? // Nullable for anonymous events
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Event details
  action   String // "rate_limit_exceeded", "login", "oauth_connect", "item_created", etc.
  resource String // Endpoint or resource identifier (e.g., "POST:/api/items")
  metadata Json? // Additional context: { ipAddress, userAgent, limit, count, etc. }

  success   Boolean  @default(true) // Whether the action succeeded
  createdAt DateTime @default(now())

  // Indexes for efficient querying
  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@index([success, createdAt])
  @@index([createdAt]) // For time-based queries and cleanup
}

// XPEvent tracks individual XP awards for audit trail and analytics
model XPEvent {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // XP details
  action   String // "save_item", "process_item", "add_reflection", "complete_quest", etc.
  xpAmount Int // Amount of XP awarded
  domainId String? // Optional: which domain this XP applies to
  domain   Domain? @relation(fields: [domainId], references: [id])

  // Reference to what triggered this XP (optional)
  itemId  String? // If XP was from processing an item
  questId String? // If XP was from completing a quest (future)

  // Metadata
  metadata Json? // Additional context (e.g., streak multiplier, bonus info)

  createdAt DateTime @default(now())

  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, action])
  @@index([domainId])
  @@index([itemId]) // For fetching XP by itemIds
  @@index([userId, itemId]) // Composite for faster XP lookups
}

// UserStats tracks aggregate user statistics
model UserStats {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Overall XP
  totalXp      Int @default(0) // Sum of all XP across all domains
  overallLevel Int @default(1) // Calculated from totalXp

  // Activity stats
  itemsSaved      Int @default(0)
  itemsProcessed  Int @default(0)
  reflections     Int @default(0)
  questsCompleted Int @default(0)

  // Streak tracking (will be expanded in Feature 5)
  currentStreak  Int       @default(0)
  longestStreak  Int       @default(0)
  lastActivityAt DateTime?
  timezone       String    @default("UTC") // User's IANA timezone for accurate streak calculations

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([totalXp(sort: Desc)]) // For leaderboards
}

// Badge represents an achievement that can be earned
model Badge {
  id          String  @id @default(cuid())
  key         String  @unique // Unique identifier (e.g., "first_item", "week_warrior")
  name        String // Display name (e.g., "First Steps", "Week Warrior")
  description String // What the badge is for
  icon        String? // Emoji or icon identifier
  rarity      String  @default("common") // "common" | "rare" | "epic" | "legendary"

  // Criteria
  criteriaType  String // "item_count" | "streak" | "domain_level" | "xp_total" | "special"
  criteriaValue Int? // Threshold value (e.g., 10 for "save 10 items")
  domainId      String? // Optional: domain-specific badge
  domain        Domain? @relation(fields: [domainId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  userBadges UserBadge[]

  @@index([key])
  @@index([domainId])
}

// UserBadge tracks which badges a user has earned
model UserBadge {
  id      String @id @default(cuid())
  userId  String
  user    User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  badgeId String
  badge   Badge  @relation(fields: [badgeId], references: [id], onDelete: Cascade)

  // Award details
  awardedAt DateTime  @default(now())
  progress  Int       @default(0) // For tracking progress toward badge (if applicable)
  seenAt    DateTime? // When user acknowledged/viewed the badge (for "NEW" indicator)

  @@unique([userId, badgeId]) // Can't earn same badge twice
  @@index([userId])
  @@index([badgeId])
  @@index([userId, seenAt]) // For querying unseen badges
}

// Social media account connections for bookmark sync
model SocialConnection {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Connection details
  provider       String // "twitter" | "instagram" | "linkedin" etc.
  providerUserId String // The user's ID on the provider platform
  providerHandle String? // Username/handle on the platform

  // OAuth tokens (encrypted at rest)
  accessToken    String    @db.Text
  refreshToken   String?   @db.Text
  tokenExpiresAt DateTime?

  // Sync state
  lastSyncAt      DateTime?
  lastSyncCursor  String? // For pagination/incremental sync
  syncEnabled     Boolean   @default(true)
  syncPreferences Json? // Provider-specific sync preferences (e.g., selected boards, per-board cursors)
  scopes          String[]  @default([]) // OAuth scopes granted by user (for auditing)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, provider]) // One connection per provider per user
  @@index([userId])
  @@index([provider, syncEnabled])
}

model Item {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Original content
  url    String
  source String? // domain extracted (e.g., "twitter.com")
  note   String? // optional user note

  // Import tracking (for synced bookmarks)
  importSource   String? // "twitter" | "instagram" | "linkedin" etc. (null = manually added)
  externalId     String? // Original post ID from the platform
  importMetadata Json? // Provider-specific metadata

  // Processed content
  title       String?
  summary     String? // bullet points as text
  tags        String[] // Postgres array - DEPRECATED: kept temporarily for migration, will be removed
  author      String? // Content creator/author name
  type        String? // "learn" | "do" | "reference"
  category    String? // "tech" | "business" | "design" | "productivity" | "learning" | "lifestyle" | "entertainment" | "news" | "other"
  rawContent  String?  @db.Text // truncated extracted text
  imageUrl    String? // thumbnail/preview image URL
  videoUrl    String? // video URL for platforms like LinkedIn, Twitter, etc.
  documentUrl String? // document/PDF URL for LinkedIn documents, reports, etc.
  embedHtml   String?  @db.Text // embed HTML for video platforms (TikTok, etc.)

  // Platform metadata (pre-computed for performance)
  platformData Json? // Stores pre-computed platform detection metadata (platform, embedUrls, flags, etc.)

  // Domain classification (for gamification)
  domainId String?
  domain   Domain? @relation(fields: [domainId], references: [id])

  // Status management
  status String @default("new") // "new" | "reviewed" | "pinned" | "deleted"

  // Timestamps
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  reviewedAt DateTime?

  // Relations
  itemTags ItemTag[] // NEW: standardized tagging system

  @@unique([userId, importSource, externalId]) // Prevent duplicate imports
  @@index([userId, status])
  @@index([userId, createdAt(sort: Desc)])
  @@index([userId, category])
  @@index([domainId])
  @@index([userId, status, createdAt(sort: Desc)]) // Composite for filtered lists
  @@index([userId, category, createdAt(sort: Desc)]) // Composite for category filtering
  @@index([userId, domainId, createdAt(sort: Desc)]) // Composite for domain filtering
}

// ============================================
// TAGGING SYSTEM
// ============================================

// Tag represents a normalized tag that can be assigned to items
model Tag {
  id             String @id @default(cuid())
  name           String @unique // Normalized form (lowercase, trimmed, e.g., "machine learning")
  displayName    String // Original casing for display (e.g., "Machine Learning")
  normalizedName String @unique // Fully normalized: lowercase, no special chars (same as name for now)
  usageCount     Int    @default(0) // Denormalized count for performance

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  itemTags ItemTag[]

  @@index([usageCount(sort: Desc)]) // For top N queries
  @@index([normalizedName]) // For fast lookups
}

// ItemTag - Join table for many-to-many relationship between Items and Tags
model ItemTag {
  id     String @id @default(cuid())
  itemId String
  item   Item   @relation(fields: [itemId], references: [id], onDelete: Cascade)
  tagId  String
  tag    Tag    @relation(fields: [tagId], references: [id], onDelete: Cascade)

  createdAt DateTime @default(now())

  @@unique([itemId, tagId]) // Prevent duplicate tag assignments
  @@index([itemId])
  @@index([tagId])
}
